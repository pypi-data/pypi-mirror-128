# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['biterator']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'biterator',
    'version': '0.4.0',
    'description': 'Bit manipulation and iteration tool suite.',
    'long_description': '# Biterator\n\n__Biterator is a Python library for dealing with bits. One at a time. But in a nice way.__\n\nThe name biterator is a portmanteau of the words \'bit\' and \'iterator\' which hints at the utility of this package. Two of\nthe most useful tools herein are:\n\n1. [`biterator.biterate(bit_values[, bit_length][, ones][, zeros])`](biterator/_biterators.py)\n2. [`biterator.Bits([bit_values][, bit_length][, ones][, zeros])`](biterator/_bits.py)\n\nThe first tool `biterate()` being a function that will attempt by a variety of techniques to return the most logical\nsequence of bits (as Booleans) for any given iterable object, and some objects that are not typically iterable, like\nintegers. It will parse strings for bit-like and byte like signatures and iterate over what it can detect.\n\nThe `Bits()` class expands upon this utility by efficiently storing bits as they are found. Further; `Bits()` supports\nall bitwise operators, and manipulation tools for convenient handling.\n\n## Installation\n\nThe biterator library is pip installable:\n\n```shell\npip install biterator\n```\n\n## Usage\n\nSome straightforward examples using the `biterate()` function:\n\n```doctest\n>>> import biterator\n\n# Iterate a list of booleans.\n>>> list(biterator.biterate([True, False, True, False]))\n[True, False, True, False]\n\n# Iterate a tuple of integer 0 and 1 literals.\n>>> list(biterator.biterate(tuple([1, 0, 1, 0])))\n[True, False, True, False]\n\n# Iterate a list of string "0" and "1" literals.\n>>> list(biterator.biterate(["1", "0", "1", "0"]))\n[True, False, True, False]\n\n```\n\nMore advanced examples:\n\n```doctest\n...\n\n# Iterate a string containing a prefixed binary number.\n>>> list(biterator.biterate("0b1010"))\n[True, False, True, False]\n\n# Iterate the bits of an integer, given it\'s total bit_length.\n>>> list(biterator.biterate(bit_values=10, bit_length=6))\n[False, False, True, False, True, False]\n\n# Iterate the bits of a raw byte-string.\n>>> list(biterator.biterate(b"U"))\n[False, True, False, True, False, True, False, True]\n\n# Iterate the bits of an integer represented as a prefixed hexadecimal string.\n>>> list(biterator.biterate("0xAF"))\n[True, False, True, False, True, True, True, True]\n\n# Iterate a generator.\n>>> list(biterator.biterate(i % 2 for i in range(4)))\n[True, False, True, False, True]\n\n```\n\nThe `Bits()` class expands upon the utility of `biterate()` by efficiently storing bits as they are iterated over.  \n`Bits()` support all bitwise operators and handles concatenation gracefully.\n\n```doctest\n>>> from biterator import Bits\n\n# Instantiate with all the types supported by biterate.\n>>> bits = Bits(\'0101\')\n>>> list(bits)\n[True, False, True, False]\n\n# Supports concatenation with naked biterable types.\n>>> "0xFF" + bits + "0000"\nBits("0b1111111101010000")\n\n# Supports all bitwise operators, also works with naked biterable types.\n>>> (Bits("1100") | Bits("0011")) & "1111"\nBits("0b1111")\n\n# Supports slicing.\n>>> Bits(\'10101010\')[0:8:2]\nBits("0b1111")\n\n```\n\n`Bits()` supports a variety of ways to represent data.\n\n```doctest\n...\n\n# Binary.\n>>> Bits("0xDEADBEEF").bin()\n\'0b1101_1110 0b1010_1101 0b1011_1110 0b1110_1111\'\n\n# Hexadecimal.\n>>> Bits("0b10111010110111000000110111100101").hex(compact=True)\n\'0xBADC0DE5\'\n\n# Raw bytes (instantiated from an integer with provided bit_length).\n>>> bytes(Bits(5735816763073854918203775149089, 104))\nb\'Hello, World!\'\n\n# Decode bytes with your favorite encoder!\n>>> Bits("0x4F682C206869204D61726B21F09F988A").decode("utf-8")\n\'Oh, hi Mark!ðŸ˜Š\'\n\n```\n\nQuickly implement complex bit operations!\n\n```doctest\n...\n\n# Implement a symmetric XOR cypher with ease! https://en.wikipedia.org/wiki/XOR_cipher\n>>> secret_code = Bits(\'0xBF658DC46D3068D57F9F61DBC676666A9A689E75DBD46F31\')\n\n# XOR each bit with a bit from the key (the key repeats over the message)\n>>> def xor_cypher(msg: Bits, key: Bits):\n...     return Bits(a ^ b for i in range(0, len(msg), len(key)) for a, b in zip(msg[i : i+len(key)], key))\n\n>>> decrypted = xor_cypher(secret_code, Bits("0xF100FBA11"))\n>>> bytes(decrypted)\nb\'Never gonna give you up!\'\n\n# Because it\'s symmetric, you change it back with the same key!\n>>> secret_code == xor_cypher(decrypted, Bits("0xF100FBA11"))\nTrue\n\n```\n\n## Contributing\n\nPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.\n\nPlease make sure to update tests as appropriate and follow all linting procedures prescribed by the project file.\n\n## Development install\n\nTo set up the development environment, fork or clone the repo and from inside the project directory run the\nfollowing is a shell separate from pycharm (Windows machines will need to run a shell with admin privileges):\n\n```shell\nsudo ./init-development.sh\n```\n\nOn Windows, PyCharm will need to be fully closed and restarted.\n\nThis will install pyenv, poetry, and activate the git-hooks for the pre-commit config.\n\n[Poetry](https://python-poetry.org/docs/master/) is used to manage the virtual environment, to add packages use:\n`poetry add <package_name>`. Please visit the poetry website for further information and instruction.\n\nGit hooks will run linting, type checking, and doctests on commit, if any checks fail the commit will be rejected.\n\n## TODO\n\n__Milestones for Version 1.0.0 release:__\n\n- [ ] Create UnitTest suite.\n- [ ] Code coverage in git-hooks.\n- [ ] Create a workflow that publishes on PR merge to master.\n- [ ] Workflow to bump patch on each commit, bump minor on each merge to master (major bump is left as manual)\n- [ ] Add agument parsing to init-development.sh to allow uninstalling.\n- [ ] Git hook to assert pyproject.toml matches .python-version and that version is installed\n- [ ] Git hook to update pyenv on all OS\'s\n- [ ] Git hook to create requrirements.txt (investigate if there is actual need for this)\n- [ ] Add more of the default pre-commit-hooks for line endings etc.\n- [ ] Add install validation to init-development.sh script.\n- [ ] In init-development.sh, validate that pyenv-win\\bin and pyenv-win\\shims has not already been added to path.\n\n## License\n\n[MIT License](https://choosealicense.com/licenses/mit/)\n\nCopyright (c) 2021 Derek Strasters\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the "Software"), to deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the\nSoftware.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.',
    'author': 'derek-strasters',
    'author_email': 'paracite.org@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'python_requires': '==3.8.10',
}


setup(**setup_kwargs)
