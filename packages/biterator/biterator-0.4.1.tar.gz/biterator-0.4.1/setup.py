# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['biterator']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'biterator',
    'version': '0.4.1',
    'description': 'Bit manipulation and iteration tool suite.',
    'long_description': '# Biterator\n\n__Biterator is a Python library for dealing with bits. One at a time. But in a nice way.__\n\nThe name biterator is a portmanteau of the words \'bit\' and \'iterator\' which hints at the core utility of this package.\nTwo of the most useful tools are:\n\n1. [`biterator.biterate()`](biterator/_biterators.py)\n2. [`biterator.Bits()`](biterator/_bits.py)\n\nThe `biterate()` function attempts to yield the most logical sequence of bits (as Booleans) for any given iterable\nobject (and even *some* objects that are not typically iterable, like integers).\n\nThe `Bits()` class expands upon this functionality by storing parsed bits and supporting all bitwise operators. It also\ndefines many methods that facilitate manipulation for convenience of use.\n\n## Installation\n\nThe biterator library is pip installable:\n\n```shell\npip install biterator\n```\n\n## Usage\n\n### Some straightforward examples using the `biterate()` function:\n\n```python\nfrom biterator import biterate\n```\n\nIterate a list of booleans.\n\n```python\nlist(biterate([True, False, True, False]))\n# [True, False, True, False]\n```\n\nIterate a tuple of integer 0 and 1 literals.\n\n```python\nlist(biterate(tuple([1, 0, 1, 0])))\n# [True, False, True, False]\n```\n\nIterate a list of string "0" and "1" literals.\n\n```python\nlist(biterate(["1", "0", "1", "0"]))\n# [True, False, True, False]\n```\n\n### Some more advanced examples:\n\nIterate a string containing a prefixed binary number.\n\n```python\nlist(biterate("0b1010"))\n# [True, False, True, False]\n```\n\nIterate the bits of an integer, given it\'s total bit_length.\n\n```python\nlist(biterate(bit_values=10, bit_length=6))\n# [False, False, True, False, True, False]\n```\n\nIterate the bits of a raw byte-string.\n\n```python\nlist(biterate(b"U"))\n# [False, True, False, True, False, True, False, True]\n```\n\nIterate the bits of an integer represented as a prefixed hexadecimal string.\n\n```python\nlist(biterate("0xAF"))\n# [True, False, True, False, True, True, True, True]\n```\n\nIterate a generator.\n\n```python\nlist(biterate(i % 2 for i in range(4)))\n# [False, True, False, True]\n```\n\n### Examples with `Bits()`\n\nThe `Bits()` class expands upon the utility of `biterate()` by efficiently storing bits as they are iterated over.\n`Bits()` support all bitwise operators and handle concatenation gracefully.\n\n```python\nfrom biterator import Bits\n```\n\nInstantiate with all the same types supported by biterate.\n\n```python\nbits = Bits(\'0101\')\nlist(bits)\n# [False, True, False, True]\n```\n\nSupports concatenation with naked biterable types.\n\n```python\n"0xFF" + bits + "0000"\n# Bits("0b1111111101010000")\n```\n\nSupports all bitwise operators, also works with naked biterable types.\n\n```python\n(Bits("1100") | Bits("0011")) & "1111"\n# Bits("0b1111")\n```\n\nSupports slicing.\n\n```python\nBits(\'10101010\')[0:8:2]\n# Bits("0b1111")\n```\n\n### `Bits()` supports a variety of ways to represent data.\n\nBinary.\n\n```python\nBits("0xDEADBEEF").bin()\n# \'0b1101_1110 0b1010_1101 0b1011_1110 0b1110_1111\'\n```\n\nHexadecimal.\n\n```python\nBits("0b10111010110111000000110111100101").hex(compact=True)\n# \'0xBADC0DE5\'\n```\n\nRaw bytes (instantiated from an integer with provided bit_length).\n\n```python\nbytes(Bits(5735816763073854918203775149089, 104))\n# b\'Hello, World!\'\n```\n\nDecode bytes with your favorite encoder!\n\n```python\nBits("0x4F682C206869204D61726B21F09F988A").decode("utf-8")\n# \'Oh, hi Mark!ðŸ˜Š\'\n```\n\n### Quickly implement complex bit operations!\n\nImplement a symmetric XOR cypher with ease! https://en.wikipedia.org/wiki/XOR_cipher\n\n```python\nsecret_code = Bits(\'0xBF658DC46D3068D57F9F61DBC676666A9A689E75DBD46F31\')\n\ndef xor_cypher(msg: Bits, key: Bits):\n    return Bits(a ^ b for i in range(0, len(msg), len(key)) for a, b in zip(msg[i: i + len(key)], key))\n\ndecrypted = xor_cypher(secret_code, Bits("0xF100FBA11"))\nbytes(decrypted)\n# b\'Never gonna give you up!\'\n```\n\nBecause it\'s symmetric, you change it back with the same key!\n\n```python\nsecret_code == xor_cypher(decrypted, Bits("0xF100FBA11"))\n# True\n```\n\n## Contributing\n\nPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.\n\nPlease make sure to update tests as appropriate and follow all linting procedures prescribed by the project file.\n\n## Development install\n\nTo set up the development environment, fork or clone the repo and from inside the project directory run the following is\na shell separate from pycharm (Windows machines will need to run a shell with admin privileges):\n\n```shell\nsudo ./init-development.sh\n```\n\nOn Windows, PyCharm will need to be fully closed and restarted.\n\nThis will install pyenv, poetry, and activate the git-hooks for the pre-commit config.\n\n[Poetry](https://python-poetry.org/docs/master/) is used to manage the virtual environment, to add packages use:\n`poetry add <package_name>`. Please visit the poetry website for further information and instruction.\n\nGit hooks will run linting, type checking, and pythons on commit, if any checks fail the commit will be rejected.\n\n## TODO\n\n__Milestones for Version 1.0.0 release:__\n\n- [ ] Create UnitTest suite.\n- [ ] Code coverage in git-hooks.\n- [ ] Create a workflow that publishes on PR merge to master.\n- [ ] Workflow to bump patch on each commit, bump minor on each merge to master (major bump is left as manual)\n- [ ] Add agument parsing to init-development.sh to allow uninstalling.\n- [ ] Git hook to assert pyproject.toml matches .python-version and that version is installed\n- [ ] Git hook to update pyenv on all OS\'s\n- [ ] Git hook to create requrirements.txt (investigate if there is actual need for this)\n- [ ] Add more of the default pre-commit-hooks for line endings etc.\n- [ ] Add install validation to init-development.sh script.\n- [ ] In init-development.sh, validate that pyenv-win\\bin and pyenv-win\\shims has not already been added to path.\n\n## License\n\n[MIT License](https://choosealicense.com/licenses/mit/)\n\nCopyright (c) 2021 Derek Strasters\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the "Software"), to deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the\nSoftware.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.',
    'author': 'derek-strasters',
    'author_email': 'paracite.org@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'python_requires': '==3.8.10',
}


setup(**setup_kwargs)
