"""
    Autobahn App API

    Was passiert auf Deutschlands Bundesstraßen? API für aktuelle Verwaltungsdaten zu Baustellen, Staus und Ladestationen. Außerdem Zugang zu Verkehrsüberwachungskameras und vielen weiteren Datensätzen.   # noqa: E501

    The version of the OpenAPI document: 1.0.1
    Contact: kontakt@bund.dev
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from deutschland.autobahn.api_client import ApiClient
from deutschland.autobahn.api_client import Endpoint as _Endpoint
from deutschland.autobahn.model.closure import Closure
from deutschland.autobahn.model.closures import Closures
from deutschland.autobahn.model.electric_charging_station import ElectricChargingStation
from deutschland.autobahn.model.electric_charging_stations import (
    ElectricChargingStations,
)
from deutschland.autobahn.model.parking_lorries import ParkingLorries
from deutschland.autobahn.model.parking_lorry import ParkingLorry
from deutschland.autobahn.model.road_id import RoadId
from deutschland.autobahn.model.roads import Roads
from deutschland.autobahn.model.roadwork import Roadwork
from deutschland.autobahn.model.roadworks import Roadworks
from deutschland.autobahn.model.warning import Warning
from deutschland.autobahn.model.warnings import Warnings
from deutschland.autobahn.model.webcam import Webcam
from deutschland.autobahn.model.webcams import Webcams
from deutschland.autobahn.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types,
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.get_charging_station_endpoint = _Endpoint(
            settings={
                "response_type": (ElectricChargingStation,),
                "auth": [],
                "endpoint_path": "/details/electric_charging_station/{stationId}",
                "operation_id": "get_charging_station",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "station_id",
                ],
                "required": [
                    "station_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "station_id": (str,),
                },
                "attribute_map": {
                    "station_id": "stationId",
                },
                "location_map": {
                    "station_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_closure_endpoint = _Endpoint(
            settings={
                "response_type": (Closure,),
                "auth": [],
                "endpoint_path": "/details/closure/{closureId}",
                "operation_id": "get_closure",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "closure_id",
                ],
                "required": [
                    "closure_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "closure_id": (str,),
                },
                "attribute_map": {
                    "closure_id": "closureId",
                },
                "location_map": {
                    "closure_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_parking_lorry_endpoint = _Endpoint(
            settings={
                "response_type": (ParkingLorry,),
                "auth": [],
                "endpoint_path": "/details/parking_lorry/{lorryId}",
                "operation_id": "get_parking_lorry",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "lorry_id",
                ],
                "required": [
                    "lorry_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "lorry_id": (str,),
                },
                "attribute_map": {
                    "lorry_id": "lorryId",
                },
                "location_map": {
                    "lorry_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_roadwork_endpoint = _Endpoint(
            settings={
                "response_type": (Roadwork,),
                "auth": [],
                "endpoint_path": "/details/roadworks/{roadworkId}",
                "operation_id": "get_roadwork",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "roadwork_id",
                ],
                "required": [
                    "roadwork_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "roadwork_id": (str,),
                },
                "attribute_map": {
                    "roadwork_id": "roadworkId",
                },
                "location_map": {
                    "roadwork_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_warning_endpoint = _Endpoint(
            settings={
                "response_type": (Warning,),
                "auth": [],
                "endpoint_path": "/details/warning/{warningId}",
                "operation_id": "get_warning",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "warning_id",
                ],
                "required": [
                    "warning_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "warning_id": (str,),
                },
                "attribute_map": {
                    "warning_id": "warningId",
                },
                "location_map": {
                    "warning_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_webcam_endpoint = _Endpoint(
            settings={
                "response_type": (Webcam,),
                "auth": [],
                "endpoint_path": "/details/webcam/{webcamId}",
                "operation_id": "get_webcam",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "webcam_id",
                ],
                "required": [
                    "webcam_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "webcam_id": (str,),
                },
                "attribute_map": {
                    "webcam_id": "webcamId",
                },
                "location_map": {
                    "webcam_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.list_autobahnen_endpoint = _Endpoint(
            settings={
                "response_type": (Roads,),
                "auth": [],
                "endpoint_path": "/",
                "operation_id": "list_autobahnen",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {},
                "attribute_map": {},
                "location_map": {},
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.list_charging_stations_endpoint = _Endpoint(
            settings={
                "response_type": (ElectricChargingStations,),
                "auth": [],
                "endpoint_path": "/{roadId}/services/electric_charging_station",
                "operation_id": "list_charging_stations",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "road_id",
                ],
                "required": [
                    "road_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "road_id": (RoadId,),
                },
                "attribute_map": {
                    "road_id": "roadId",
                },
                "location_map": {
                    "road_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.list_closures_endpoint = _Endpoint(
            settings={
                "response_type": (Closures,),
                "auth": [],
                "endpoint_path": "/{roadId}/services/closure",
                "operation_id": "list_closures",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "road_id",
                ],
                "required": [
                    "road_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "road_id": (RoadId,),
                },
                "attribute_map": {
                    "road_id": "roadId",
                },
                "location_map": {
                    "road_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.list_parking_lorries_endpoint = _Endpoint(
            settings={
                "response_type": (ParkingLorries,),
                "auth": [],
                "endpoint_path": "/{roadId}/services/parking_lorry",
                "operation_id": "list_parking_lorries",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "road_id",
                ],
                "required": [
                    "road_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "road_id": (RoadId,),
                },
                "attribute_map": {
                    "road_id": "roadId",
                },
                "location_map": {
                    "road_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.list_roadworks_endpoint = _Endpoint(
            settings={
                "response_type": (Roadworks,),
                "auth": [],
                "endpoint_path": "/{roadId}/services/roadworks",
                "operation_id": "list_roadworks",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "road_id",
                ],
                "required": [
                    "road_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "road_id": (RoadId,),
                },
                "attribute_map": {
                    "road_id": "roadId",
                },
                "location_map": {
                    "road_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.list_warnings_endpoint = _Endpoint(
            settings={
                "response_type": (Warnings,),
                "auth": [],
                "endpoint_path": "/{roadId}/services/warning",
                "operation_id": "list_warnings",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "road_id",
                ],
                "required": [
                    "road_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "road_id": (RoadId,),
                },
                "attribute_map": {
                    "road_id": "roadId",
                },
                "location_map": {
                    "road_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.list_webcams_endpoint = _Endpoint(
            settings={
                "response_type": (Webcams,),
                "auth": [],
                "endpoint_path": "/{roadId}/services/webcam",
                "operation_id": "list_webcams",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "road_id",
                ],
                "required": [
                    "road_id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "road_id": (RoadId,),
                },
                "attribute_map": {
                    "road_id": "roadId",
                },
                "location_map": {
                    "road_id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )

    def get_charging_station(self, station_id, **kwargs):
        """Details zu einer Ladestation  # noqa: E501

        Gibt Details zu einer konkreten Ladestation zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_charging_station(station_id, async_req=True)
        >>> result = thread.get()

        Args:
            station_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ElectricChargingStation
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["station_id"] = station_id
        return self.get_charging_station_endpoint.call_with_http_info(**kwargs)

    def get_closure(self, closure_id, **kwargs):
        """Details zu einer Sperrung  # noqa: E501

        Gibt Details zu einer konkreten Sperrung zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_closure(closure_id, async_req=True)
        >>> result = thread.get()

        Args:
            closure_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Closure
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["closure_id"] = closure_id
        return self.get_closure_endpoint.call_with_http_info(**kwargs)

    def get_parking_lorry(self, lorry_id, **kwargs):
        """Details eines Rastplatzes  # noqa: E501

        Gibt Details eines konkreten Rastplatzes zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_parking_lorry(lorry_id, async_req=True)
        >>> result = thread.get()

        Args:
            lorry_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ParkingLorry
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["lorry_id"] = lorry_id
        return self.get_parking_lorry_endpoint.call_with_http_info(**kwargs)

    def get_roadwork(self, roadwork_id, **kwargs):
        """Details einer Baustelle  # noqa: E501

        Gibt Details zu einer konkreten Baustelle zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_roadwork(roadwork_id, async_req=True)
        >>> result = thread.get()

        Args:
            roadwork_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Roadwork
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["roadwork_id"] = roadwork_id
        return self.get_roadwork_endpoint.call_with_http_info(**kwargs)

    def get_warning(self, warning_id, **kwargs):
        """Details zu einer Verkehrsmeldung  # noqa: E501

        Gibt Details zu einer konkreten Verkehrsmeldung zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_warning(warning_id, async_req=True)
        >>> result = thread.get()

        Args:
            warning_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Warning
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["warning_id"] = warning_id
        return self.get_warning_endpoint.call_with_http_info(**kwargs)

    def get_webcam(self, webcam_id, **kwargs):
        """Details einer Webcam  # noqa: E501

        Gibt Details einer konkreten Webcam zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_webcam(webcam_id, async_req=True)
        >>> result = thread.get()

        Args:
            webcam_id (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Webcam
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["webcam_id"] = webcam_id
        return self.get_webcam_endpoint.call_with_http_info(**kwargs)

    def list_autobahnen(self, **kwargs):
        """Liste verfügbarer Autobahnen  # noqa: E501

        Gibt eine Liste der verfügbaren Autobahnen zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_autobahnen(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Roads
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.list_autobahnen_endpoint.call_with_http_info(**kwargs)

    def list_charging_stations(self, road_id, **kwargs):
        """Liste aktueller Ladestationen  # noqa: E501

        Gibt eine Liste der Ladestationen zu einer Autobahn zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_charging_stations(road_id, async_req=True)
        >>> result = thread.get()

        Args:
            road_id (RoadId):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ElectricChargingStations
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["road_id"] = road_id
        return self.list_charging_stations_endpoint.call_with_http_info(**kwargs)

    def list_closures(self, road_id, **kwargs):
        """Liste aktueller Sperrungen  # noqa: E501

        Gibt eine Liste der Sperrungen zu einer Autobahn zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_closures(road_id, async_req=True)
        >>> result = thread.get()

        Args:
            road_id (RoadId):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Closures
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["road_id"] = road_id
        return self.list_closures_endpoint.call_with_http_info(**kwargs)

    def list_parking_lorries(self, road_id, **kwargs):
        """Liste verfügbarer Rastplätze  # noqa: E501

        Gibt eine Liste der Rastplätze zu einer Autobahn zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_parking_lorries(road_id, async_req=True)
        >>> result = thread.get()

        Args:
            road_id (RoadId):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ParkingLorries
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["road_id"] = road_id
        return self.list_parking_lorries_endpoint.call_with_http_info(**kwargs)

    def list_roadworks(self, road_id, **kwargs):
        """Liste aktueller Baustellen  # noqa: E501

        Gibt eine Liste der aktuellen Baustellen zu einer Autobahn zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_roadworks(road_id, async_req=True)
        >>> result = thread.get()

        Args:
            road_id (RoadId):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Roadworks
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["road_id"] = road_id
        return self.list_roadworks_endpoint.call_with_http_info(**kwargs)

    def list_warnings(self, road_id, **kwargs):
        """Liste aktueller Verkehrsmeldungen  # noqa: E501

        Gibt eine Liste der Verkehrsmeldungen zu einer Autobahn zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_warnings(road_id, async_req=True)
        >>> result = thread.get()

        Args:
            road_id (RoadId):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Warnings
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["road_id"] = road_id
        return self.list_warnings_endpoint.call_with_http_info(**kwargs)

    def list_webcams(self, road_id, **kwargs):
        """Liste verfügbarer Webcams  # noqa: E501

        Gibt eine Liste der Webcams zu einer Autobahn zurück.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_webcams(road_id, async_req=True)
        >>> result = thread.get()

        Args:
            road_id (RoadId):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            Webcams
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["road_id"] = road_id
        return self.list_webcams_endpoint.call_with_http_info(**kwargs)
