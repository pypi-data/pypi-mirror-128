# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['healpix_alchemy']

package_data = \
{'': ['*']}

install_requires = \
['astropy', 'astropy_healpix', 'mocpy>=0.10.0', 'sqlalchemy']

setup_kwargs = {
    'name': 'healpix-alchemy',
    'version': '1.0.0',
    'description': 'SQLAlchemy extensions for HEALPix spatially indexed astronomy data',
    'long_description': "# HEALPix Alchemy\n\nThe `healpix_alchemy` Python package is an extension for the [SQLAlchemy]\nobject relational mapper. It adds region and image arithmetic to [PostgreSQL]\n(version 14 and newer) databases. It accelerates queries between point clouds,\nregions, and images (sometimes known in the geospatial community as rasters) by\nstoring [multi-order] [HEALPix] indices in PostgreSQL's [range types].\n\nThe `healpix_alchemy` project is designed for astronomy applications,\nparticularly for cross-matching galaxy catalogs, observation footprints, and\nall-sky images like [gravitational-wave probability sky maps] or even dust\nmaps. However, it could be used in any context in which geometry is embedded on\na unit sphere.\n\n`healpix_alchemy` is lean and minimalist because it leverages several existing\nprojects: it consists of little more than a few lines of glue code to bind\ntogether [MOCPy], [SQLAlchemy], and PostgreSQL's [range types].\n\n`healpix_alchemy` serves a purpose similar to full-featured astronomy-focused\nspatial extensions like [Q3C], [H3C], and [pg_healpix], and geospatial\nextensions like [PgSphere] and [PostGIS]. What sets `healpix_alchemy` apart\nfrom these is that it is written in pure Python and requires no server-side\ndatabase extensions. Consequently, `healpix_alchemy` can be used with managed\nPostgreSQL databases in the cloud like [Amazon RDS] and [Google Cloud SQL].\n\n[2MASS Redshift Survey]: https://lweb.cfa.harvard.edu/~dfabricant/huchra/2mass/\n[Aladin]: https://aladin.u-strasbg.fr\n[Amazon RDS]: https://aws.amazon.com/rds/\n[astropy.coordinates.SkyCoord]: https://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html#astropy.coordinates.SkyCoord\n[astropy.units.Quantity]: https://docs.astropy.org/en/stable/api/astropy.units.Quantity.html#astropy.units.Quantity\n[custom column types]: https://docs.sqlalchemy.org/en/14/core/custom_types.html\n[Google Cloud SQL]: https://cloud.google.com/sql\n[Górski et al. (2005)]: https://doi.org/10.1086/427976\n[gravitational-wave probability sky maps]: https://emfollow.docs.ligo.org/userguide/tutorial/skymaps.html\n[GW200115_042309]: https://doi.org/10.3847/2041-8213/ac082e\n[H3C]: http://cdsarc.u-strasbg.fr/h3c\n[HEALPix]: https://healpix.sourceforge.io\n[hierarchical progressive surveys (HiPS)]: https://www.ivoa.net/documents/HiPS/\n[ICRS]: https://docs.astropy.org/en/stable/api/astropy.coordinates.builtin_frames.ICRS.html#astropy.coordinates.builtin_frames.ICRS\n[ligo-segments]: https://lscsoft.docs.ligo.org/ligo-segments/\n[MOCPy documentation]: https://cds-astro.github.io/mocpy/\n[MOCPy]: https://github.com/tboch/mocpy\n[multi-order coverage (MOC)]: https://ivoa.net/documents/MOC/\n[multi-order]: https://doi.org/10.1051/0004-6361/201526549\n[pg_healpix]: https://github.com/segasai/pg_healpix\n[PgSphere]: https://pgsphere.github.io\n[PostGIS]: https://postgis.net\n[PostgreSQL]: https://www.postgresql.org\n[pyranges]: https://github.com/biocore-ntnu/pyranges\n[Q3C]: https://github.com/segasai/q3c\n[range types]: https://www.postgresql.org/docs/current/rangetypes.html\n[S200115j]: https://gracedb.ligo.org/superevents/S200115j/view/\n[Singer & Price (2015)]: https://doi.org/10.1103/PhysRevD.93.024013\n[SQLAlchemy bulk insertion]: https://docs.sqlalchemy.org/en/14/orm/persistence_techniques.html#bulk-operations\n[SQLAlchemy]: https://www.sqlalchemy.org\n[UNIQ]: https://healpix.sourceforge.io/doc/html/intro_Geometric_Algebraic_Propert.htm#SECTION420\n[Zwicky Transient Facility]: https://www.ztf.caltech.edu\n\n## Theory of operation\n\n### HEALPix basics\n\n[HEALPix] is a scheme for subdividing and indexing the unit sphere, originally\ndescribed by [Górski et al. (2005)]. Although it was originally designed for\ncosmic microwave background analysis, it has found many uses in astronomy,\nparticularly through [multi-order coverage (MOC)] maps and\n[hierarchical progressive surveys (HiPS)] used extensively in the [Aladin]\nastronomical information system. It is also used by LIGO and Virgo to store and\ncommunicate [gravitational-wave probability sky maps].\n\nHEALPix can be thought of as a tree. At the lowest resolution, level 0, HEALPix\nsubdivides the sphere into 12 equal-area base tiles, assigned integer indicies\n0 through 11. At level 1, each of the 12 base tiles is subdivided into 4 tiles.\nEvery subsequent level divides each of the preceding level's tiles into 4 new\ntiles. At a given level, each of the base pixels has been divided into\n4<sup>_level_</sup> pixels (_nside_ = 2<sup>_level_</sup> pixels on each side).\nThus there are _npix_ = 12×4<sup>_level_</sup> pixels at a given resolution,\nassigned integer indices from 0 through (_npix_-1). This is called the NESTED\nindexing scheme. (There is also a RING indexing scheme in which the indicies\nadvance from east to west and then from north to south.)\n\nA HEALPix tile, a node in the HEALPix tree, is fully addressed by three pieces\nof information: the indexing scheme (RING or NESTED), the resolution level\n(_level_ or equivalently _nside_), and the pixel index (_ipix_, an integer\nbetween 0 and _npix_-1).\n\nThe image below, reproduced from https://healpix.jpl.nasa.gov, illustrates the\nfirst 4 levels of refinement of a HEALPix grid.\n\n![The first four levels of HEALPix subdivision of the unit sphere](https://healpix.jpl.nasa.gov/images/healpixGridRefinement.jpg)\n\n### HEALPix interval sets\n\nA region on the sphere can be encoded by a collection of disjoint HEALPix\ntiles, potentially at a mix of different resolution levels. Typically, large\nlow-resolution tiles are used on the interior of the region, and small\nhigh-resolution tiles are used on the boundary. This is called a\n[multi-order coverage (MOC)] map. An example, reproduced from the\n[MOCPy documentation], is shown below.\n\n![An example HEALPix multi-order coverage map](https://cds-astro.github.io/mocpy/_images/plot_SDSS_r.png)\n\nMuch like MOCs, LIGO/Virgo/KAGRA gravitational-wave probability sky maps are\nstored as multi-resolution HEALPix data sets, but with a vector of\nfloating-point values attached to each tile. A multi-order refinement mesh from\nan example sky map is shown below, reproduced from [Singer & Price (2015)].\n\n![Example multi-order refinement mesh from a gravitational-wave probability sky map](https://emfollow.docs.ligo.org/userguide/_images/healpix-adaptive-mesh.svg)\n\n[Reinecke & Hivon (2015)][multi-order] introduced HEALPix interval sets as an\nalternative encoding of MOCs that enables fast and simple unions,\nintersections, and queries. In an interval set, each HEALPix tile is described\nby the interval of pixel indices at some very high resolution\n_level_<sub>max</sub> that are descendents of that tile. In an interval set, a\nregion is encoded as a disjoint collection of such intervals. A tile with a\nNESTED address given by (_level_, _ipix_) may be described as the half-open\ninterval\n\n[_ipix_ 4<sup>_level_<sub>max</sub> - _level_</sup>,\n(_ipix_ + 1) 4<sup>_level_<sub>max</sub> - _level_</sup>).\n\nWe use _level_<sub>max</sub> = 29 because this is the highest resolution at\nwhich pixel indices can be stored in a signed 64-bit integer. At this\nresolution, each pixel is scarcely 0.4 milliarcseconds across.\n\nThe interval set representation is adventageous because there are simple and\nfast algorithms for interval arithmetic and set operations. Interval analysis\nappears in a suprising variety of scientific contexts from [genomics][pyranges]\nto [gravitational wave data quality][ligo-segments]. Because of the many\nbusiness applications of interval arithmetic, intervals are also supported in\nthe [PostgreSQL] database through its [range types].\n\n### Spatial primitives in `healpix_alchemy`\n\nThe `healpix_alchemy` package provides two [custom column types] for\n[SQLAlchemy]:\n\n#### `healpix_alchemy.Point`\n\nThis class represents a point. A column of this type could store the positions\nof galaxies in a catalog. Under the hood, it is just a `BIGINT`.\n\nWherever you need to bind a Python value to a `healpix_alchemy.Point`, you may\nprovide any one of the following:\n* an instance of [astropy.coordinates.SkyCoord]\n* a sequence of two [astropy.units.Quantity] instances with angle units, which\n  will be interpreted as the right ascension and declination of the point in\n  the [ICRS] frame\n* an integer representing the HEALPix NESTED index of the point at\n  _level_ = _level_<sub>max</sub>\n\n#### `healpix_alchemy.Tile`\n\nThis class represents a HEALPix tile. A table containing a column of this type\nand a foreign key could store MOCs or gravitational-wave probability maps.\nUnder the hood, it is just an `INT8RANGE`.\n\nWherever you need to bind a Python value to a `healpix_alchemy.Tile`, you may\nprovide any one of the following:\n* A single integer which will be interpreted as the address of the tile in the\n  [UNIQ] HEALPix indexing scheme\n* A sequence of two integers, which will be interpreted as the lower and upper\n  bounds of the right-half-open pixel index interval at\n  _level_ = _level_<sub>max</sub>\n* A string like `'[1234,5678)'`\n\n## Installation\n\nYou can install `healpix_alchemy` from the Python Package Index using [pip]:\n\n```console\n$ pip install healpix-alchemy\n```\n\n[pip]: https://pip.pypa.io/\n\n## Example\n\nFirst, some imports:\n\n```pycon\n>>> import sqlalchemy as sa\n>>> from sqlalchemy.ext.declarative import as_declarative, declared_attr\n>>> import healpix_alchemy as ha\n\n```\n\n### Set up tables\n\nThis example will use the SQLAlchemy declarative extension for describing table\nschema using Python classes.\n\nSQLAlchemy needs to know the name for each table. You can provide the name by\nsetting the `__tablename__` attribute in each model class, or you can\ncreate a base class that generates the table name automatically from the class\nname.\n\n```pycon\n>>> @as_declarative()\n... class Base:\n...\n...     @declared_attr\n...     def __tablename__(cls):\n...         return cls.__name__.lower()\n\n```\n\nEach row of the `Galaxy` table represents a point in a catalog:\n\n```pycon\n>>> class Galaxy(Base):\n...     id = sa.Column(sa.Text, primary_key=True)\n...     healpix = sa.Column(ha.Point, index=True, nullable=False)\n\n```\n\nEach row of the `Field` table represents a ZTF field:\n\n```pycon\n>>> class Field(Base):\n...     id = sa.Column(sa.Integer, primary_key=True)\n...     tiles = sa.orm.relationship(lambda: FieldTile)\n\n```\n\nEach row of the `FieldTile` represents a multi-resolution HEALPix tile that is\ncontained within the corresponding field. There is a one-to-many mapping\nbetween `Field` and `FieldTile`.\n\n```pycon\n>>> class FieldTile(Base):\n...     id = sa.Column(sa.ForeignKey(Field.id), primary_key=True)\n...     healpix = sa.Column(ha.Tile, primary_key=True, index=True)\n\n```\n\nEach row of the `Localization` table represents a LIGO/Virgo HEALPix\nlocalization map.\n\n```pycon\n>>> class Localization(Base):\n...     id = sa.Column(sa.Integer, primary_key=True)\n...     tiles = sa.orm.relationship(lambda: LocalizationTile)\n\n```\n\nEach row of the `LocalizationTile` table represents a multi-resolution HEALPix\ntile within a LIGO/Virgo localization map. There is a one-to-many mapping\nbetween `Localization` and `LocalizationTile`.\n\n```pycon\n>>> class LocalizationTile(Base):\n...     id = sa.Column(sa.ForeignKey(Localization.id), primary_key=True)\n...     healpix = sa.Column(ha.Tile, primary_key=True, index=True)\n...     probdensity = sa.Column(sa.Float, nullable=False)\n\n```\n\nFinally, connect to the database, create all the tables, and start a session.\n\n```pycon\n>>> engine = sa.create_engine('postgresql://user:password@host/database')\n>>> Base.metadata.create_all(engine)\n>>> session = sa.orm.Session(engine)\n\n```\n\n### Populate with sample data\n\nLoad the [2MASS Redshift Survey] into the `Galaxy` table. This catalog contains\n44599 galaxies.\n\nIt may take up to a minute for this to finish. Advanced users may speed this up\nsignificantly by vectorizing the conversion from `SkyCoord` to HEALPix indices\nand using [SQLAlchemy bulk insertion].\n\n```pycon\n>>> from astropy.coordinates import SkyCoord\n>>> from astroquery.vizier import Vizier\n>>> vizier = Vizier(columns=['SimbadName', 'RAJ2000', 'DEJ2000'], row_limit=-1)\n>>> data, = vizier.get_catalogs('J/ApJS/199/26/table3')\n>>> data['coord'] = SkyCoord(data['RAJ2000'], data['DEJ2000'])\n>>> for row in data:\n...     session.add(Galaxy(id=row['SimbadName'], healpix=row['coord']))\n>>> session.commit()\n\n```\n\nLoad the footprints of the [Zwicky Transient Facility] fields into the `Field`\nand `FieldTile` tables.\n\nIt may take up to a minute for this to finish. Advanced users may speed this up\nsignificantly by using [SQLAlchemy bulk insertion].\n\n```pycon\n>>> from astropy.table import Table\n>>> from astropy.coordinates import SkyCoord\n>>> from astropy import units as u\n>>> url = 'https://raw.githubusercontent.com/ZwickyTransientFacility/ztf_information/master/field_grid/ztf_field_corners.csv'\n>>> for row in Table.read(url):\n...     field_id = int(row['field'])\n...     corners = SkyCoord([row['ra1'], row['ra2'], row['ra3'], row['ra4']],\n...                        [row['dec1'], row['dec2'], row['dec3'], row['dec4']],\n...                        unit=u.deg)\n...     tiles = [FieldTile(healpix=hpx) for hpx in ha.Tile.tiles_from(corners)]\n...     session.add(Field(id=field_id, tiles=tiles))\n>>> session.commit()\n\n```\n\nLoad a sky map for LIGO/Virgo event [GW200115_042309] ([S200115j]) into the\n`Localization` and `LocalizationTile` tables.\n\n```pycon\n>>> url = 'https://gracedb.ligo.org/apiweb/superevents/S200115j/files/bayestar.multiorder.fits'\n>>> data = Table.read(url)\n>>> tiles = [LocalizationTile(healpix=row['UNIQ'], probdensity=row['PROBDENSITY']) for row in data]\n>>> session.add(Localization(id=1, tiles=tiles))\n>>> session.commit()\n\n```\n\n### Sample Queries\n\n#### What is the area of each field?\n\n```pycon\n>>> query = sa.select(\n...     FieldTile.id, sa.func.sum(FieldTile.healpix.area)\n... ).group_by(\n...     FieldTile.id\n... ).limit(\n...     5\n... )\n>>> for field_id, area in session.execute(query):\n...     print('Field', field_id, 'has area', area, 'steradians')\nField 199 has area 0.017380122168993366 steradians\nField 200 has area 0.017376127427358248 steradians\nField 201 has area 0.017377126112767028 steradians\nField 202 has area 0.017376127427358248 steradians\nField 203 has area 0.017375128741949467 steradians\n\n```\n\n#### How many galaxies are in each field?\n\n```pycon\n>>> count = sa.func.count(Galaxy.id)\n>>> query = sa.select(\n...     FieldTile.id, count\n... ).filter(\n...     FieldTile.healpix.contains(Galaxy.healpix)\n... ).group_by(\n...     FieldTile.id\n... ).order_by(\n...     count.desc()\n... ).limit(\n...     5\n... )\n>>> for field_id, count in session.execute(query):\n...     print('Field', field_id, 'contains', count, 'galaxies')\nField 1739 contains 343 galaxies\nField 699 contains 336 galaxies\nField 700 contains 311 galaxies\nField 225 contains 303 galaxies\nField 1740 contains 289 galaxies\n\n```\n\n#### What is the probability density at the position of each galaxy?\n\n```pycon\n>>> query = sa.select(\n...     Galaxy.id, LocalizationTile.probdensity\n... ).filter(\n...     LocalizationTile.id == 1,\n...     LocalizationTile.healpix.contains(Galaxy.healpix)\n... ).order_by(\n...     LocalizationTile.probdensity.desc()\n... ).limit(\n...     5\n... )\n>>> for galaxy_id, probdensity in session.execute(query):\n...     print('Galaxy', galaxy_id, 'has probability density', probdensity, 'per steradian')\nGalaxy 2MASX J02532153+0632222 has probability density 20.70119818753699 per steradian\nGalaxy 2MASX J02530482+0555431 has probability density 20.69509436913713 per steradian\nGalaxy 2MASX J02533119+0628252 has probability density 20.668990360570593 per steradian\nGalaxy 2MASX J02524584+0639206 has probability density 20.656073554123115 per steradian\nGalaxy 2MASX J02534120+0615562 has probability density 20.56675452367264 per steradian\n\n```\n\n#### What is the probability contained within each field?\n\n```pycon\n>>> prob = sa.func.sum(LocalizationTile.probdensity * (FieldTile.healpix * LocalizationTile.healpix).area)\n>>> query = sa.select(\n...     FieldTile.id, prob\n... ).filter(\n...     LocalizationTile.id == 1,\n...     FieldTile.healpix.overlaps(LocalizationTile.healpix)\n... ).group_by(\n...     FieldTile.id\n... ).order_by(\n...     prob.desc()\n... ).limit(\n...     5\n... )\n>>> for field_id, prob in engine.execute(query):\n...     print('Field', field_id, 'containment probability is', prob)\nField 1499 containment probability is 0.1647961222933018\nField 1446 containment probability is 0.15593990703399768\nField 452 containment probability is 0.15420100565087086\nField 505 containment probability is 0.09911749170919448\nField 401 containment probability is 0.09621300206793466\n\n```\n\n#### What is the combined area of fields 1000 through 2000?\n\nIn the next two examples, we introduce `healpix_alchemy.func.union()` which\nfinds the union of a set of tiles. Because it is an aggregate function, it\nshould generally be used in a subquery.\n\n```pycon\n>>> union = sa.select(\n...     ha.func.union(FieldTile.healpix).label('healpix')\n... ).filter(\n...     FieldTile.id.between(1000, 2000)\n... ).subquery()\n>>> query = sa.select(\n...     sa.func.sum(union.columns.healpix.area)\n... )\n>>> result = session.execute(query).scalar_one()\n>>> print(result, 'steradians')\n9.332762083260642 steradians\n\n```\n\n#### What is the integrated probability contained within fields 1000 through 2000?\n\n```pycon\n>>> union = sa.select(\n...     ha.func.union(FieldTile.healpix).label('healpix')\n... ).filter(\n...     FieldTile.id.between(1000, 2000)\n... ).subquery()\n>>> prob = sa.func.sum(LocalizationTile.probdensity * (union.columns.healpix * LocalizationTile.healpix).area)\n>>> query = sa.select(\n...     prob\n... ).filter(\n...     LocalizationTile.id == 1,\n...     union.columns.healpix.overlaps(LocalizationTile.healpix)\n... )\n>>> session.execute(query).scalar_one()\n0.8373173527131985\n\n```\n\n#### What is the area of the 90% credible region?\n\n```pycon\n>>> cum_area = sa.func.sum(\n...     LocalizationTile.healpix.area\n... ).over(\n...     order_by=LocalizationTile.probdensity.desc()\n... ).label(\n...     'cum_area'\n... )\n>>> cum_prob = sa.func.sum(\n...     LocalizationTile.probdensity * LocalizationTile.healpix.area\n... ).over(\n...     order_by=LocalizationTile.probdensity.desc()\n... ).label(\n...     'cum_prob'\n... )\n>>> subquery = sa.select(\n...     cum_area,\n...     cum_prob\n... ).filter(\n...     LocalizationTile.id == 1\n... ).subquery()\n>>> query = sa.select(\n...     sa.func.max(subquery.columns.cum_area)\n... ).filter(\n...     subquery.columns.cum_prob <= 0.9\n... )\n>>> result = session.execute(query).scalar_one()\n>>> print(result, 'steradians')\n0.2766278687487106 steradians\n\n```\n\n#### Which galaxies are within the 90% credible region?\n\n```pycon\n>>> cum_prob = sa.func.sum(\n...     LocalizationTile.probdensity * LocalizationTile.healpix.area\n... ).over(\n...     order_by=LocalizationTile.probdensity.desc()\n... ).label(\n...     'cum_prob'\n... )\n>>> subquery1 = sa.select(\n...     LocalizationTile.probdensity,\n...     cum_prob\n... ).filter(\n...     LocalizationTile.id == 1\n... ).subquery()\n>>> min_probdensity = sa.select(\n...     sa.func.min(subquery1.columns.probdensity)\n... ).filter(\n...     subquery1.columns.cum_prob <= 0.9\n... ).scalar_subquery()\n>>> query = sa.select(\n...     Galaxy.id\n... ).filter(\n...     LocalizationTile.id == 1,\n...     LocalizationTile.healpix.contains(Galaxy.healpix),\n...     LocalizationTile.probdensity >= min_probdensity\n... ).limit(\n...     5\n... )\n>>> for galaxy_id, in session.execute(query):\n...     print(galaxy_id)\n2MASX J02424077-0000478\n2MASX J02352772-0921216\n2MASX J02273746-0109226\n2MASX J02414523+0026354\n2MASX J20095408-4822462\n\n```\n",
    'author': 'Leo Singer',
    'author_email': 'leo.singer@ligo.org',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/skyportal/healpix-alchemy',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
