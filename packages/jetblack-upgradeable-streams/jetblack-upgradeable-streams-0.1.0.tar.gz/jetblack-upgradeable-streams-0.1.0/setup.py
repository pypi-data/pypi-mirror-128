# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['upgradeable_streams']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'jetblack-upgradeable-streams',
    'version': '0.1.0',
    'description': 'An experiment in upgradeable streams',
    'long_description': '# asyncio-upgradeable-streams\n\nAn experiment in upgradeable streams.\n\n## Overview\n\nAn upgradeable stream starts life as a plain socket connection, but is capable\nof being "upgraded" to TLS. This is sometimes known as [STARTTLS](https://en.wikipedia.org/wiki/Opportunistic_TLS). Common examples of this are\nSMTP, LDAP, and HTTP proxy tunneling with CONNECT.\n\nThe asyncio library provides [loop.start_tls](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.start_tls) for this purpose.\nThis project provides an implementation of [asyncio.open_connection](https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection)\nand [asyncio.start_server](https://docs.python.org/3/library/asyncio-stream.html#asyncio.start_server)\nwith an extra optional boolean parameter `upgradeadble`. When this is set, the `writer` has a new method `upgrade` which can be called to\nupgrade the connection to TLS.\n\nThis was tested using Python 3.9.7 on Ubuntu Linux 21.10.\n\n## Issues\n\nThe solution makes use of private variables in the python standard library which\nmay change at the will of the python library maintainer.\n\n# Installation\n\nThis can be installed with pip.\n\n```bash\npip install jetblack-upgradeable-streams\n```\n\n## Examples\n\nThe following examples can be found in the "demos" folder. They expect a Linux\nenvironment.\n\n### Client\n\nHere is the client. A new argument `upgradeable` has been added to the\n`open_connection` function, to enable upgrading. The `writer` has a new method\n`upgrade` to upgrade the connection.\n\nThe client connects without TLS.\n\nFirst the client sends "PING" to the server. The server should respond\nwith "PONG".\n\nNext the client sends "STARTTLS" to instruct the server to upgrade the\nconnection to TLS. The client then calls the `upgrade` method on the `writer` to\nnegotiate the secure connection. The method returns a new `reader` and `writer`.\n\nUsing the new writer the client sends "PING" to the server, this time over the\nencrypted stream. The server should respond with "PONG".\n\nFinally the client sends "QUIT" to the server and closes the connection.\n\n```python\nimport asyncio\nimport socket\nimport ssl\n\nfrom upgradeable_streams import open_connection\n\n\nasync def start_client():\n    ctx = ssl.create_default_context(\n        purpose=ssl.Purpose.SERVER_AUTH,\n        cafile=\'/etc/ssl/certs/ca-certificates.crt\'\n    )\n    host = socket.getfqdn()\n\n    print("Connect to server as upgradeable")\n    reader, writer = await open_connection(\n        host,\n        10001,\n        ssl=ctx,\n        upgradeable=True\n    )\n\n    print(f"The writer ssl context is {writer.get_extra_info(\'sslcontext\')}")\n\n    print("Sending PING")\n    writer.write(b\'PING\\n\')\n    response = (await reader.readline()).decode(\'utf-8\').rstrip()\n    print(f"Received: {response}")\n\n    print("Sending STARTTLS")\n    writer.write(b\'STARTTLS\\n\')\n\n    print("Upgrading the connection")\n    # Upgrade\n    reader, writer = await writer.upgrade()\n\n    print(f"The writer ssl context is {writer.get_extra_info(\'sslcontext\')}")\n\n    print("Sending PING")\n    writer.write(b\'PING\\n\')\n    response = (await reader.readline()).decode(\'utf-8\').rstrip()\n    print(f"Received: {response}")\n\n    print("Sending QUIT")\n    writer.write(b\'QUIT\\n\')\n    await writer.drain()\n\n    print("Closing client")\n    writer.close()\n    await writer.wait_closed()\n    print("Client disconnected")\n\nif __name__ == \'__main__\':\n    asyncio.run(start_client())\n```\n\n### Server\n\nAn extra argument `upgradeable` has been added to the `start_server` function\nto enable upgrading to TLS. The `writer` has a new method `upgrade` to upgrade\nthe connection to TLS.\n\nThe server listens for client connections.\n\nOn receiving a connection it enters a read loop.\n\nWhen the server receives "PING" it responds with "PONG".\n\nWhen the server receives "QUIT" it closes the connection.\n\nWhen the server receives "STARTTLS" it calls the `upgrade` method on the `writer`\nto negotiate the TLS connection. The method returns a new `reader` and `writer`.\n\nThe code expects certificate and key PEM files in "~/.keys/server.{crt,key}".\n\n```python\nimport asyncio\nfrom asyncio import StreamReader, StreamWriter\nfrom os.path import expanduser\nimport socket\nimport ssl\nfrom typing import Union\n\nfrom upgradeable_streams import start_server, UpgradeableStreamWriter\n\n\nasync def handle_client(\n        reader: StreamReader,\n        writer: Union[UpgradeableStreamWriter, StreamWriter]\n) -> None:\n    print("Client connected")\n\n    while True:\n        request = (await reader.readline()).decode(\'utf8\').rstrip()\n        print(f"Read \'{request}\'")\n\n        if request == \'QUIT\':\n            break\n\n        elif request == \'PING\':\n            print("Sending pong")\n            writer.write(b\'PONG\\n\')\n            await writer.drain()\n\n        elif request == \'STARTTLS\':\n            if not isinstance(writer, UpgradeableStreamWriter):\n                raise ValueError(\'writer not upgradeable\')\n            print("Upgrading connection to TLS")\n            # Upgrade\n            reader, writer = await writer.upgrade()\n\n    print("Closing client")\n    writer.close()\n    await writer.wait_closed()\n    print("Client closed")\n\n\nasync def run_server():\n    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    ctx.load_verify_locations(cafile="/etc/ssl/certs/ca-certificates.crt")\n    ctx.load_cert_chain(\n        expanduser("~/.keys/server.crt"),\n        expanduser("~/.keys/server.key")\n    )\n    host = socket.getfqdn()\n\n    print("Starting server as upgradeable")\n    server = await start_server(\n        handle_client,\n        host,\n        10001,\n        ssl=ctx,\n        upgradeable=True\n    )\n\n    async with server:\n        await server.serve_forever()\n\nif __name__ == \'__main__\':\n    asyncio.run(run_server())\n```\n',
    'author': 'Rob Blackbourn',
    'author_email': 'rob.blackbourn@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/rob-blackbourn/asyncio-upgradeable-streams',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
