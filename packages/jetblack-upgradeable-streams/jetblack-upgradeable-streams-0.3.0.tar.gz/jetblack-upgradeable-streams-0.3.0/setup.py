# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['upgradeable_streams']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'jetblack-upgradeable-streams',
    'version': '0.3.0',
    'description': 'An experiment in upgradeable streams',
    'long_description': '# asyncio-upgradeable-streams\n\nAn experiment in upgradeable streams.\n\n## Overview\n\nAn upgradeable stream starts life as a plain socket connection, but is capable\nof being "upgraded" to TLS. This is sometimes known as\n[STARTTLS](https://en.wikipedia.org/wiki/Opportunistic_TLS).\nCommon examples of this are SMTP, LDAP, and HTTP proxy tunneling with CONNECT.\n\nThe asyncio library provides\n[loop.start_tls](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.start_tls)\nfor this purpose, however there is little information on how this can be used.\n\nThis project provides an implementation of\n[asyncio.open_connection](https://docs.python.org/3/library/asyncio-stream.html#asyncio.open_connection)\nand [asyncio.start_server](https://docs.python.org/3/library/asyncio-stream.html#asyncio.start_server)\nwith an extra optional boolean parameter `upgradeadble`. When this is set the\nTLS negotiation is deferred, and the `writer` has a new method `start_tls` which\ncan be called to upgrade the connection to TLS.\n\nThis was tested using Python 3.9.7 on Ubuntu Linux 21.10.\n\n## Issues\n\nThe solution makes use of private variables in the python standard library which\nmay change at the will of the python library maintainer. In particular it has\nto reset the reader in the `StreamReaderProtocol` and the transport in the\n`StreamWriter`.\n\n## Installation\n\nThis can be installed with pip.\n\n```bash\npip install jetblack-upgradeable-streams\n```\n\n## Examples\n\nThe following examples can be found in the "demos" folder. They expect a Linux\nenvironment.\n\n### Client\n\nA new argument `upgradeable` has been added to the\n`open_connection` function to enable upgrading. When `upgradeable` is `True`\nthe TLS negotiation is deferred and the `ssl` parameter is stored for use when\nthe connection is upgraded.\nThe `writer` has a new method `start_tls` to upgrade the connection to TLS.\n\n1. The client connects without TLS.\n\n2. First the client sends "PING" to the server. The server should respond\n   with "PONG".\n\n3. Next the client sends "STARTTLS" to instruct the server to upgrade the\n   connection to TLS. The client then calls the `start_tls` method on the\n   `writer` to negotiate the secure connection. The method returns a new\n   `reader` and `writer`.\n\n4. Using the new writer the client sends "PING" to the server, this time over\n   the encrypted stream. The server should respond with "PONG".\n\n5. Finally the client sends "QUIT" to the server and closes the connection.\n\n```python\nimport asyncio\nimport socket\nimport ssl\n\nfrom upgradeable_streams import open_connection\n\n\nasync def start_client():\n    ctx = ssl.create_default_context(\n        purpose=ssl.Purpose.SERVER_AUTH,\n        cafile=\'/etc/ssl/certs/ca-certificates.crt\'\n    )\n    host = socket.getfqdn()\n\n    print("Connect to server as upgradeable")\n    reader, writer = await open_connection(\n        host,\n        10001,\n        ssl=ctx,\n        upgradeable=True\n    )\n\n    print(f"The writer ssl context is {writer.get_extra_info(\'sslcontext\')}")\n\n    print("Sending PING")\n    writer.write(b\'PING\\n\')\n    response = (await reader.readline()).decode(\'utf-8\').rstrip()\n    print(f"Received: {response}")\n\n    print("Sending STARTTLS")\n    writer.write(b\'STARTTLS\\n\')\n\n    print("Upgrading the connection")\n    # Upgrade\n    reader, writer = await writer.start_tls()\n\n    print(f"The writer ssl context is {writer.get_extra_info(\'sslcontext\')}")\n\n    print("Sending PING")\n    writer.write(b\'PING\\n\')\n    response = (await reader.readline()).decode(\'utf-8\').rstrip()\n    print(f"Received: {response}")\n\n    print("Sending QUIT")\n    writer.write(b\'QUIT\\n\')\n    await writer.drain()\n\n    print("Closing client")\n    writer.close()\n    await writer.wait_closed()\n    print("Client disconnected")\n\nif __name__ == \'__main__\':\n    asyncio.run(start_client())\n```\n\n### Server\n\nAn extra argument `upgradeable` has been added to the `start_server` function\nto enable upgrading to TLS. The `ssl` context is stored for use when a client\nconnection is upgraded to TLS.\nThe `writer` has a new method `start_tls` to upgrade the connection to TLS.\n\n1. The server listens for client connections.\n\n2. On receiving a connection it enters a read loop.\n\n3. When the server receives "PING" it responds with "PONG".\n\n4. When the server receives "STARTTLS" it calls the `start_tls` method on the\n   `writer` to negotiate the TLS connection. The method returns a new `reader`\n   and `writer`.\n\n5. When the server receives "QUIT" it closes the connection.\n\nThe code expects certificate and key PEM files in "~/.keys/server.{crt,key}".\n\n```python\nimport asyncio\nfrom asyncio import StreamReader, StreamWriter\nfrom os.path import expanduser\nimport socket\nimport ssl\nfrom typing import Union\n\nfrom upgradeable_streams import start_server, UpgradeableStreamWriter\n\n\nasync def handle_client(\n        reader: StreamReader,\n        writer: Union[UpgradeableStreamWriter, StreamWriter]\n) -> None:\n    print("Client connected")\n\n    while True:\n        request = (await reader.readline()).decode(\'utf8\').rstrip()\n        print(f"Read \'{request}\'")\n\n        if request == \'QUIT\':\n            break\n\n        elif request == \'PING\':\n            print("Sending pong")\n            writer.write(b\'PONG\\n\')\n            await writer.drain()\n\n        elif request == \'STARTTLS\':\n            if not isinstance(writer, UpgradeableStreamWriter):\n                raise ValueError(\'writer not upgradeable\')\n            print("Upgrading connection to TLS")\n            # Upgrade\n            reader, writer = await writer.start_tls()\n\n    print("Closing client")\n    writer.close()\n    await writer.wait_closed()\n    print("Client closed")\n\n\nasync def run_server():\n    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    ctx.load_verify_locations(cafile="/etc/ssl/certs/ca-certificates.crt")\n    ctx.load_cert_chain(\n        expanduser("~/.keys/server.crt"),\n        expanduser("~/.keys/server.key")\n    )\n    host = socket.getfqdn()\n\n    print("Starting server as upgradeable")\n    server = await start_server(\n        handle_client,\n        host,\n        10001,\n        ssl=ctx,\n        upgradeable=True\n    )\n\n    async with server:\n        await server.serve_forever()\n\nif __name__ == \'__main__\':\n    asyncio.run(run_server())\n```\n\n## Development\n\nPull requests are welcome. In particular anything to reduce the reliance on the\nimplementation details in the standard library.\n',
    'author': 'Rob Blackbourn',
    'author_email': 'rob.blackbourn@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/rob-blackbourn/asyncio-upgradeable-streams',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
