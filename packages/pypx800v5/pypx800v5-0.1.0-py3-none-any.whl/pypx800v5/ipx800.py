"""Get information and control a GCE IPX800v5."""
import asyncio
import socket

import aiohttp
import async_timeout

from .const import EXTENSIONS

from .exceptions import (Ipx800CannotConnectError, Ipx800InvalidAuthError,
                         Ipx800RequestError)


class IPX800:
    """Class representing the IPX800 and its API."""

    def __init__(
        self,
        host: str,
        api_key: str,
        port: int = 80,
        request_timeout: int = 5,
        session: aiohttp.client.ClientSession = None,
    ) -> None:
        """Init a IPX800v4 API."""
        self.host = host
        self.port = port
        self._api_key = api_key

        self._request_timeout = request_timeout

        self._base_api_url = f"http://{host}:{port}/api/"

        self._api_version = ""
        self._extensions = []

        self._session = session
        self._close_session = False

        if self._session is None:
            self._session = aiohttp.ClientSession()
            self._close_session = True

    async def _request_api(self, path, data: dict = None, params: dict = None, method: str = "GET") -> dict:
        """Make a request to get the IPX800 JSON API."""
        params_with_api = {"ApiKey": self._api_key}
        if params is not None:
            params_with_api.update(params)

        try:
            with async_timeout.timeout(self._request_timeout):
                response = await self._session.request(
                    method=method,
                    url=self._base_api_url + path,
                    params=params_with_api,
                    json=data
                )

            if response.status == 401:
                raise Ipx800InvalidAuthError()

            if response.status >= 200 and response.status <= 206:
                content = await response.json()
                response.close()
                return content

            content = await response.json()
            raise Ipx800RequestError("IPX800 API request error, error code", response.status)

        except asyncio.TimeoutError as exception:
            raise Ipx800CannotConnectError(
                "Timeout occurred while connecting to IPX800."
            ) from exception
        except (aiohttp.ClientError, socket.gaierror) as exception:
            raise Ipx800CannotConnectError(
                "Error occurred while communicating with the IPX800."
            ) from exception

    async def ping(self) -> bool:
        """Return True if the IPX800 answer to API request."""
        try:
            result = await self._request_api("system/ipx")
            return result.get("errorStatus") == 0
        except Ipx800CannotConnectError:
            pass
        return False

    async def get_ipx_config(self) -> dict:
        """Get IPX config."""
        return await self._request_api("system/ipx")

    async def get_ipx_info(self) -> dict:
        """Get IPX config."""
        infos = await self._request_api("system/ipx/info")
        self._api_version = infos["apiVersion"]
        return infos

    async def update_io(self, value: bool) -> None:
        """Update an IO on the IPX."""
        await self._request_api("system/ipx", method="PUT", data={
            "on": value
        })

    @property
    def api_version(self) -> str:
        """Return API version."""
        return self._api_version

    @property
    def extensions(self) -> dict:
        """Get the list of connected extensions."""
        return self._extensions

    async def discover_extensions(self) -> None:
        """Update the list of connected extensions."""
        extensions = []
        for type_extension in EXTENSIONS:
            try:
                for extension in await self._request_api(f"ebx/{type_extension}"):
                    extensions.append({
                        "type": type_extension,
                        "id": extension["_id"],
                        "name": extension["name"]
                    })
            except Ipx800RequestError:
                print("Error to get %s extensions" % type_extension)
        self._extensions = extensions

    async def global_get(self) -> dict:
        """Get all values from the IPX800 answer."""
        values = await self._request_api("core/io")
        return values

    def get_ext_id(self, ext_type, ext_number) -> str:
        """Return the unique extension id generated by the IPX."""
        extensions = [x for x in self.extensions if x["type"] == ext_type]
        return extensions[ext_number - 1]["id"] 
        # TODO Raise error if extension not existing ? or return empty str

    async def close(self) -> None:
        """Close open client session."""
        if self._session and self._close_session:
            await self._session.close()

    async def __aenter__(self):
        """Async enter."""
        return self

    async def __aexit__(self, *_exc_info) -> None:
        """Async exit."""
        await self.close()
